<html>
<!$Id: manual.html,v 1.4 2003/04/28 16:02:58 tomas Exp $>

<head>
<style type="text/css">
ul { list-style-type: disc };
</style>
</head>

<body bgcolor="#FFFFFF">

<hr>

<center>
<table border=0 cellspacing=2 cellpadding=2>
<tr><td align=center><a href="http://www.lua.org">
<img border=0 alt="The Lua language" src="lua.png"></a>
<tr><td align=center><big><b>LuaSQL Reference Manual</b></big>
<tr><td align=center valign=top>Database connectivity for the Lua language
</table>
</center>
<p>

<center><small>
<a href="index.html#over">overview</a> &middot;
<a href="index.html#version">current version</a> &middot;
<a href="index.html#new">what's new</a> &middot;
<a href="index.html#down">download</a> &middot;
<a href="index.html#hist">history</a>
</small></center>
<p>

<hr>

<a name="overview"></a>
<h2>Overview</h2>
<p>
This library is a suite of drivers
each one composed by two files: a C source file that implements the
driver functions; and a Lua script used to load the dynamic library.
The host application can be statically linked with one or more drivers
or they can be loaded dynamically by the corresponding Lua script (that
requires the built-in <tt>loadlib</tt> function Lua 5 offers).
</p><p>
Both ways when the driver is loaded it creates a method in a table
called <tt>luasql</tt>; this method has the same name of the driver
(postgres, odbc etc.).
This method is used to create an <a href="#environment_class">Environment
object</a> which is the basis to do whatever is needed.
</p><p>
LuaSQL has a common API that all drivers must implement,
but other especial features can exist.
This manual tries to explain both the common API and the particularities
of each driver.
</p>


<a name="environment_class">
<h2>Environment class</h2>
<p>
An Environment object is created by calling the method with the
same name of the driver (odbc, postgres etc.).
For example, <tt>luasql.odbc()</tt>, will try to create an environment
object using the ODBC driver.
</p>

<h4>Methods</h4>

<ul>
<a name="env_connect"></a>
<li> <tt>connect (sourcename [, username [, password]])</tt> <br>
Connects to a data source specified in <tt>sourcename</tt> using 
<tt>username</tt> and <tt>password</tt> if they are supplied.<br>
Returns: a <a href="connection_class">Connection object</a>.
<ul> PostgreSQL extension:
<li> Two more optionsl parameters (hostname and port)
<li> Just one string containing all connection info, as described in
     the PostgreSQL manual ("host=&lt;<i>source name</i>&gt; port=&lt;<i>port number</i>&gt;" etc.)
</ul>

<a name="env_close"></a>
<li> <tt>close ()</tt> <br>
Closes this environment. Only successful if all connections pertaining to
it were closed first.
</ul>

<a name="connection_class">
<h2>Connection class</h2>

A Connection object contains specific attributes and parameters of a single
data source connection.
A Connection object is created by calling the
<tt><a href="#env_connect">environment:connect</a></tt>
method.

<h4>Methods</h4>

<ul>
<a name="conn_execute"></a>
<li> <tt>execute (statement)</tt> <br>
Executes the given SQL <tt>statement</tt>.<br>
Returns: a <a href="cursor_class">Cursor object</a>
if there are results, or the number of rows affected by the command otherwise.

<a name="conn_setautocommit"></a>
<li> <tt>setautocommit (boolean)</tt> <br>
Turns on or off the "auto commit" mode.

<!--
<li> <tt>TableList()</tt> <br>==&gt; So' no ODBC &lt;==
Retrieves a list of all the tables in the data source. <br>
Returns: a list of the table names.
</p>
-->
<a name="conn_commit"></a>
<li> <tt>commit()</tt> <br>
Commits the current transaction.

<a name="conn_rollback"></a>
<li> <tt>rollback()</tt> <br>
Rolls back the current transaction.

<a name="conn_close"></a>
<li> <tt>close()</tt> <br>
Closes this connection.
Only successful if all cursors pertaining to it were closed first.
</ul>


<a name="cursor_class"></a>
<h3>Cursor class</h3>

A Cursor object contains methods permitting the retrieval of 
data resulting from an executed statement.
A Cursor object is created by using the
<tt><a href="#conn_execute">Connection:execute</a></tt>
function.

<h4>Methods</h4>

<ul>
<a name="cur_fetch"></a>
<li> <tt>fetch ([table[,modestring]])</tt> <br>
Retrieves the next row of results.<br>
If <tt>fetch</tt> is called without parameters,
the results will be returned to the caller directly.
If <tt>fetch</tt> is called with a table, the results will be copied
to the table.
In this case, an optional <tt>mode</tt> parameter can be used.
It is just a string indicating how the result table should be made.
The mode string can contain:
<ul>
  <li> <b>"n"</b> the resulting table will have numerical indices
  <li> <b>"a"</b> the resulting table will have alphanumerical indices
</ul>
The optional <tt>table</tt> parameter is a table that should be
used to store the next row.
This should improve the performance when retrieving many rows with many fields.<br>
Returns: data, as above, or <tt>nil</tt> if there aren't any rows left
followed by an error message if any.

<a name="cur_colinfo"></a>
<li> <tt>colinfo()</tt> <br>

<a name="cur_close"></a>
<li> <tt>close()</tt> <br>
Closes this cursor. 
</ul>

<h3><a name=ex>Examples</h3>

Below is a small sample code displaying the basic use of the library.

<blockquote>
<pre>
-- create environment object
ENV, err = SQLOpen()
assert(ENV, err)
-- connect to ODBC data source
CON, err = ENV:Connect("LuaSQLTest")
assert(CON, err)
-- reset our table
res, err = CON:Execute"DROP TABLE friends"
res, err = CON:Execute[[
  CREATE TABLE friends(
    friendid Number,
    friendname  String, 
    friendage Number);
]]
assert(res, err)
-- add a few elements
friends = {
  {ID = 1, Name = "John", Age = 24}, 
  {ID = 2, Name = "Mary", Age = 21}, 
  {ID = 5, Name = "Anaconda", Age = 70},
  {ID = 3, Name = "Rita", Age = 28}, 
  {ID = 4, Name = "Stephan", Age = 23}
}
for i, f in friends do
  res, err = CON:Execute(format([[
    INSERT INTO friends(friendid, friendname, friendage)
    VALUES(%d, '%s', %d)]], f.ID, f.Name, f.Age)
  )
  assert(res, err)
end
-- retrieve a cursor for all friends, sorted by age
CUR, err = CON:Execute[[
	SELECT friendname, friendage FROM friends ORDER BY friendage
]]
assert(CUR, err)
-- rows will be indexed by column name
res, err = CUR:SetOptions{name_columns = "true"}
assert(res, err)
-- print all rows of the result
while 1 do
	row = CUR:Fetch()
	if not row then break end
	print(format("Name: %s, Age: %d", row.friendname, row.friendage))
end
-- close everything
CUR:Close()
CON:Close()
ENV:Close()
</pre>
</blockquote>

And the output of this script should be:

<blockquote>
<pre>
Name: Mary, Age: 21
Name: Stephan, Age: 23
Name: John, Age: 24
Name: Rita, Age: 28
Name: Anaconda, Age: 70
</pre>
</blockquote>

Notes: 
<ul>
<li> The above sample is adjusted to work with the ODBC driver. In case
you want to test it with the PostgreSQL driver, you must change the DDL
entries from '<tt>Number</tt>' to '<tt>int</tt>' and '<tt>String</tt>' to
'<tt>varchar(64)</tt>'.
<li> Also, tables and columns names have all been written in lowercase,
because some drivers are case-insensitive whereas others are
case-sensitive.
</ul>

<h2>Contents</h2>
<p>
<ul>
<li> <a href="#overview">Overview</a>
<li> <a href="#environment_class">Environment class</a>
  <ul>
    <li> <a href="#env_close">close</a>
    <li> <a href="#env_connect">connect</a>
  </ul>
<li> <a href="#connection_class">Connection class</a>
  <ul>
    <li> <a href="#conn_close">close</a>
    <li> <a href="#conn_execute">execute</a>
    <li> <a href="#conn_commit">commit</a>
    <li> <a href="#conn_rollback">rollback</a>
    <li> <a href="#conn_setautocommit">setautocommit</a>
  </ul>
<li> <a href="#cursor">Cursor class</a>
  <ul>
    <li> <a href="#cur_close">close</a>
    <li> <a href="#cur_fetch">fetch</a>
    <li> <a href="#cur_colinfo">colinfo</a>
    <li> <a href="#cur_numrows">numrows</a>
  </ul>
<li> <a href="#examples">Examples</a>
</ul>
</p>


<p>
<center>
<a href=#over>overview</a> &middot;
<a href=#current>current version</a> &middot;
<a href=#new>what's new</a> &middot;
<a href=#down>download</a> &middot;
<a href=#manual>manual</a> &middot;
<a href=#hist>history</a>
</center>
<p>

<hr>
<small>
Last modified by Tom&aacute;s Guisasola on<br>
Wed Feb 19 13:52:33 BRT 2003
</small>

</body>
</html> 
